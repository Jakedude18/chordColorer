<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maximally Even Chord Colorer</title>
<script src="https://cdn.tailwindcss.com"></script>
<style type="text/tailwindcss">
/* Custom piano key styles */
.white-key { @apply w-10 h-40 border border-gray-400 bg-white rounded-sm; }
.white-key.selected { @apply bg-gray-500; }
.white-key.lightup { @apply bg-orange-500; }

.black-key { @apply absolute w-7 h-24 bg-black rounded-sm z-10; }
.black-key.selected { @apply bg-gray-700; }
.black-key.lightup { @apply bg-orange-400; }
</style>
</head>
<body class="bg-gray-50 text-gray-900 font-sans min-h-screen p-6 flex flex-col items-center">

<h1 class="text-3xl md:text-4xl font-bold mb-8 text-center text-indigo-700">Maximally Even Chord Colorer</h1>

<!-- Panels -->
<div class="flex flex-col md:flex-row gap-6 justify-center mb-8 w-full max-w-6xl">
  <!-- Base Chord Panel -->
  <div class="bg-white border border-gray-300 shadow-md rounded-lg p-6 flex-1 min-w-[280px]">
    <label class="block font-semibold mb-2">1) Select Base Chord</label>
    <div class="relative select-none" id="basePiano">
      <div class="flex h-40" id="baseWhiteKeys"></div>
      <div class="absolute top-0 left-0 h-24 w-full" id="baseBlackKeys"></div>
    </div>
  </div>

  <!-- Mode Panel -->
  <div class="bg-white border border-gray-300 shadow-md rounded-lg p-6 flex-1 min-w-[280px]">
    <label class="block font-semibold mb-2">2) Select Mode</label>
    <div class="relative select-none" id="modePiano">
      <div class="flex h-40" id="modeWhiteKeys"></div>
      <div class="absolute top-0 left-0 h-24 w-full" id="modeBlackKeys"></div>
    </div>
  </div>

  <!-- Controls Panel -->
  <div class="bg-white border border-gray-300 shadow-md rounded-lg p-6 flex-1 min-w-[280px]">
    <label class="block font-semibold mb-2">3) Number of Color Notes</label>
    <select id="colorCount" class="w-full p-2 border border-gray-300 rounded mb-4"></select>

    <div class="flex flex-wrap gap-2 mb-4">
      <button class="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors" onclick="colorChord()">Color Chord</button>
      <button class="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 transition-colors" onclick="playChord()">Play Chord</button>
      <button class="px-4 py-2 bg-indigo-500 text-white rounded hover:bg-purple-600 transition-colors" onclick="demoExample()">Demo</button>
      <label class="flex items-center gap-1 ml-2">
        <input type="checkbox" id="arpeggioToggle" checked class="accent-indigo-500"> Arpeggiate
      </label>
    </div>

    <label class="block font-semibold mb-1">Mode (readout)</label>
    <pre id="modeOut" class="bg-gray-100 p-2 rounded text-sm">[]</pre>
  </div>
</div>

<!-- Results & Circle -->
<div class="flex flex-col md:flex-row gap-6 justify-center items-start w-full max-w-6xl mb-8">
  <canvas id="circleCanvas" width="520" height="520" class="border border-gray-300 rounded-lg bg-white shadow-sm"></canvas>

  <div class="flex flex-col gap-2 max-w-[220px]">
    <h3 class="font-semibold text-lg mb-2">Results</h3>
    <b>Final coloring (PCs)</b>
    <pre id="finalPCs" class="bg-gray-100 p-2 rounded">—</pre>
    <b>Readable</b>
    <pre id="finalNames" class="bg-gray-100 p-2 rounded">—</pre>
    <b>Evenness</b>
    <div id="evennessOut" class="mt-1">—</div>
  </div>
</div>

<!-- Description -->
<div class="text-gray-700 max-w-4xl text-center mb-6">
  Musicians often refer to adding notes to a chord as coloring. This tool colors a chord as evenly as possible from a mode while using a base set of notes. For more information see my <a href="https://github.com/Jakedude18/chordColorer">Github.</a>

</div>

<footer class="text-gray-500 text-sm text-center">
  Demo colors a C chord with base {C,G} with one color note {E} using Ionian mode to generate a major chord.
</footer>
<script>
// ================= Utilities =================
const noteNames=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
const pcToName=pc=>noteNames[(pc+12)%12];

// ================= Piano =================
const whitePCs=[0,2,4,5,7,9,11];
const blackLayout=[{pc:1,left:30},{pc:3,left:70},{pc:6,left:150},{pc:8,left:190},{pc:10,left:230}];

const baseSet=new Set(), modeSet=new Set();
const modeOut = document.getElementById("modeOut");

let lastFinalColoring=[], lastBaseChord=[], lastChordSize=0;

// ================= Build Keyboard =================
function buildKeyboard(whiteEl,blackEl,set){
  whitePCs.forEach(pc=>{
    const k=document.createElement("div"); k.className="white-key"; k.dataset.pc=pc; k.onclick=()=>toggle(k,pc,set); whiteEl.appendChild(k);
  });
  blackLayout.forEach(o=>{
    const k=document.createElement("div"); k.className="black-key"; k.style.left=o.left+"px"; k.dataset.pc=o.pc;
    k.onclick=e=>{e.stopPropagation(); toggle(k,o.pc,set);}; blackEl.appendChild(k);
  });
}
buildKeyboard(baseWhiteKeys,baseBlackKeys,baseSet);
buildKeyboard(modeWhiteKeys,modeBlackKeys,modeSet);

// ================= Dynamic Color Count =================
const colorSelect = document.getElementById("colorCount");
function updateColorOptions(){
  const maxColor = Math.max(1,7-baseSet.size);
  colorSelect.innerHTML="";
  for(let i=1;i<=maxColor;i++){
    const opt=document.createElement("option");
    opt.value=i;
    opt.textContent=i;
    colorSelect.appendChild(opt);
  }
  if(colorSelect.value>maxColor) colorSelect.value=maxColor;
}

// ================= Toggle Function =================
function toggle(el,pc,set){
  if(set.has(pc)){
    set.delete(pc);
    el.classList.remove("selected");
  } else {
    set.add(pc);
    el.classList.add("selected");
  }
  if(set === modeSet){
    updateModeOut();
  }
  else {
    updateColorOptions(); // update color dropdown whenever base chord changes
  }
}


function updateModeOut(){
  const arr = [...modeSet].sort((a,b)=>a-b);
  modeOut.textContent = "[" + arr.join(",") + "]";
}

// ================= Canvas =================
const canvas=circleCanvas, ctx=canvas.getContext("2d");
const cx=260,cy=260,R=170;
function ang(pc){return pc/12*2*Math.PI-Math.PI/2;}
function drawBaseCircle(){
  ctx.beginPath(); ctx.arc(cx,cy,R,0,2*Math.PI); ctx.strokeStyle="#ddd"; ctx.lineWidth=1.5; ctx.stroke();
  for(let pc=0; pc<12; pc++){
    const a=ang(pc),x=cx+Math.cos(a)*(R+26),y=cy+Math.sin(a)*(R+26)+4;
    ctx.fillStyle="#333"; ctx.font="12px Arial"; ctx.fillText(pcToName(pc),x-10,y);
  }
}

function drawNormalPolygon(onsets, offset = 0) {
  const pts = [];

  for (let k = 0; k < onsets; k++) {
    // shift by `offset` semitone ticks
    const tick = (k * 12 / onsets) + offset;
    const a = ang(tick);

    pts.push({
      x: cx + R * Math.cos(a),
      y: cy + R * Math.sin(a)
    });
  }

  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
  ctx.closePath();

  ctx.fillStyle = "rgba(180,180,180,0.06)";
  ctx.strokeStyle = "rgba(120,120,120,0.45)";
  ctx.lineWidth = 1.6;
  ctx.fill();
  ctx.stroke();

  pts.forEach(p => {
    ctx.beginPath();
    ctx.fillStyle = "rgba(120,120,120,0.6)";
    ctx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
    ctx.fill();
  });
}




function drawChordPolygon(pcs,highlightPc=-1,highlightColor=null){
  if(!pcs||!pcs.length)return;
  const pts=pcs.map(p=>({pc:p,a:ang(p),x:cx+R*Math.cos(ang(p)),y:cy+R*Math.sin(ang(p))})).sort((A,B)=>A.a-B.a);
  ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y);
  for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x,pts[i].y);
  ctx.closePath(); ctx.fillStyle="rgba(200,40,40,0.12)";
  ctx.strokeStyle="rgba(200,40,40,0.95)"; ctx.lineWidth=3; ctx.fill(); ctx.stroke();
  pts.forEach(p=>{
    ctx.beginPath();
    ctx.fillStyle=(highlightPc===p.pc)?highlightColor:"rgba(200,40,40,1)";
    ctx.arc(p.x,p.y,7,0,2*Math.PI); ctx.fill();
    ctx.fillStyle="#fff"; ctx.font="11px Arial"; ctx.fillText(p.pc,p.x-6,p.y+4);
  });
}
function drawAll(pcs,onsets,highlightPc=-1,highlightColor=null, offset){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawBaseCircle(); drawNormalPolygon(onsets, offset); drawChordPolygon(pcs,highlightPc,highlightColor);
}

// ================= Server =================
function chordSize(){
  lastChordSize = (+colorCount.value) + lastBaseChord.length;
  return lastChordSize;
}

function colorChord(){
  const base=[...baseSet], mode=[...modeSet];
  lastBaseChord=base.slice();
  fetch("/compute_chord",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({baseChord:base,mode:mode,onsets:chordSize()})})
  .then(r=>r.json()).then(d=>{
    lastFinalColoring=d.bestColoring||[];
    finalPCs.textContent="["+lastFinalColoring.join(",")+"]";
    finalNames.textContent="["+lastFinalColoring.map(pcToName).join(",")+"]";
    evennessOut.textContent=d.maxEvenness.toFixed(4);
    drawAll(lastFinalColoring, chordSize(), -1, null, d.offset);
  });
}

// ================= Audio =================
const AudioCtx=window.AudioContext||window.webkitAudioContext;
const audioCtx=new AudioCtx();

function playNote(pc,oct,delay=0){
  const osc=audioCtx.createOscillator();
  const g=audioCtx.createGain();
  const midi=60+pc+12*(oct-4);
  const freq=440*Math.pow(2,(midi-69)/12);
  osc.frequency.value=freq;
  g.gain.setValueAtTime(0.0001,audioCtx.currentTime+delay);
  g.gain.exponentialRampToValueAtTime(0.2,audioCtx.currentTime+0.02+delay);
  g.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+0.8+delay);
  osc.connect(g).connect(audioCtx.destination);
  osc.start(audioCtx.currentTime+delay); osc.stop(audioCtx.currentTime+0.9+delay);
}

function highlightKey(pc,isBase){
  const container=isBase?"#basePiano":"#modePiano";
  const color=isBase?"lightup":"lightup";
  document.querySelectorAll(`${container} [data-pc='${pc}']`).forEach(k=>{
    k.classList.add(color);
    setTimeout(()=>k.classList.remove(color),200);
  });
}

// ================= Play Chord =================
function playChord(){
  if(!lastFinalColoring.length) return;

  const base = new Set(lastBaseChord);
  const arpeggio = arpeggioToggle.checked;

  const baseNotes = lastFinalColoring.filter(pc=>base.has(pc)).sort((a,b)=>a-b);
  const colorNotes = lastFinalColoring.filter(pc=>!base.has(pc)).sort((a,b)=>a-b);

  if(arpeggio){
    const ordered = [...baseNotes,...colorNotes];
    ordered.forEach((pc,i)=>{
      const isBase = base.has(pc);
      playNote(pc,isBase?4:5,i*0.25);
      setTimeout(()=>highlightKey(pc,isBase),i*250);
    });
  } else {
    lastFinalColoring.forEach(pc=>{
      const isBase = base.has(pc);
      playNote(pc,isBase?4:5);
      highlightKey(pc,isBase);
    });
  }
}

// ================= Demo =================
function demoExample(){
  baseSet.clear(); modeSet.clear();
  [0,7].forEach(p=>baseSet.add(p));
  [0,2,4,5,7,9,11].forEach(p=>modeSet.add(p));
  document.querySelectorAll(".white-key,.black-key").forEach(k=>k.classList.remove("selected"));
  document.querySelectorAll("#basePiano [data-pc]").forEach(k=>baseSet.has(+k.dataset.pc)&&k.classList.add("selected"));
  document.querySelectorAll("#modePiano [data-pc]").forEach(k=>modeSet.has(+k.dataset.pc)&&k.classList.add("selected"));
  modeOut.textContent="[0,2,4,5,7,9,11]";
  updateColorOptions();
  colorChord();
}

// ================= Init =================
updateColorOptions();
</script>
</body>
</html>
